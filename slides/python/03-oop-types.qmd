---
title: "Python Session 3 — OOP and Types"
subtitle: "Classes, dataclasses, typing, exceptions"
author: "Juan F. Imbet"
institute: "Paris Dauphine University-PSL"
format:
  revealjs:
    theme: white
    css: styles.css
    slide-number: true
    chalkboard: true
    preview-links: auto
    footer: "Intro to VBA and Python"
    include-in-header: ../../tikzjax.html
execute:
  enabled: false
---

## Why OOP?

- Organize code around data + behavior


---

## Basic class

```python
class Account:
    def __init__(self, owner: str, balance: float = 0.0):
        self.owner = owner
        self.balance = balance
    def deposit(self, amount: float):
        self.balance += amount
```

---

## Methods and self

- self is the instance being acted upon
- Methods are functions attached to a class

---

## Properties

```python
class Temperature:
    def __init__(self, c: float):
        self._c = c
    @property
    def celsius(self):
        return self._c
    @celsius.setter
    def celsius(self, v):
        self._c = v
```

---

## Inheritance

```python
class Savings(Account):
    def interest(self, rate: float):
        self.balance *= (1 + rate)
```

---

## Composition over inheritance

- Combine objects to build bigger ones


---

## Dataclasses

```python
from dataclasses import dataclass

@dataclass
class Order:
    id: int
    item: str
    qty: int = 1
```

- Generates __init__, __repr__, comparisons

---

## Typing basics

```python
from typing import List, Dict, Optional
```

- Helps tools catch mistakes; doesn’t change runtime

---

## Generics and Protocols (brief)

- List[int], Dict[str, float]
- Structural typing (duck typing) via Protocols

---

## Exceptions as control flow for errors

```python
def divide(a: float, b: float) -> float:
    if b == 0:
        raise ValueError("b must not be zero")
    return a / b
```

---

## Testing mindset

- Write small tests for class behavior
- Use assert statements or pytest

---

## Exercise 1

- Build a Bank with Accounts; deposit/withdraw; compute interest

---

## Exercise 2

- Convert an existing dict into a dataclass and add methods

---

## Equality and hashing

```python
from dataclasses import dataclass
@dataclass(frozen=True)
class Point:
    x: int; y: int
```

- Hashable → usable in sets/dicts

---

## __repr__ and __str__

- Human vs debug representations

---

## Static and class methods

```python
class C:
    @staticmethod
    def util(): ...
    @classmethod
    def from_str(cls, s): ...
```

---

## Type checking tools

- mypy, pyright; gradual typing in practice

---

## Encapsulation conventions

- Use leading underscore `_attr` to signal internal attributes
- Avoid exposing mutable references; return copies or read-only views

---

## Name mangling (double underscore)

```python
class Safe:
    def __init__(self):
        self.__pin = 1234  # becomes _Safe__pin
    def check(self, x):
        return x == self.__pin
```

---

## __slots__ to save memory

```python
class Point2D:
    __slots__ = ("x", "y")
    def __init__(self, x: float, y: float):
        self.x, self.y = x, y
```

- Prevents dynamic attributes; reduces per-instance memory

---

## Abstract Base Classes (ABC)

```python
from abc import ABC, abstractmethod

class PriceSource(ABC):
    @abstractmethod
    def get_price(self, symbol: str) -> float: ...

class YahooSource(PriceSource):
    def get_price(self, symbol): return 123.45
```

---

## Multiple inheritance and MRO

- Use sparingly; inspect Method Resolution Order via `C.mro()`

---

## Dataclasses: default_factory

```python
from dataclasses import dataclass, field

@dataclass
class Portfolio:
    name: str
    positions: dict[str, float] = field(default_factory=dict)
```

---

## Dataclasses: post-init and validation

```python
from dataclasses import dataclass

@dataclass
class Trade:
    symbol: str
    qty: int
    def __post_init__(self):
        if self.qty == 0:
            raise ValueError("qty must be non-zero")
```

---

## Protocols with example

```python
from typing import Protocol

class HasArea(Protocol):
    def area(self) -> float: ...

class Circle:
    def __init__(self, r: float): self.r = r
    def area(self) -> float: return 3.1416*self.r*self.r
```

---

## Generic classes

```python
from typing import Generic, TypeVar
T = TypeVar('T')

class Box(Generic[T]):
    def __init__(self, value: T): self.value = value
```

---

## TypedDict and NewType

```python
from typing import TypedDict, NewType

class UserTD(TypedDict):
    id: int
    name: str

UserId = NewType('UserId', int)
```

---

## Context managers in classes

```python
class Locker:
    def __enter__(self): print("lock"); return self
    def __exit__(self, exc_type, exc, tb): print("unlock"); return False
```

---

## Operator overloading

```python
from dataclasses import dataclass
@dataclass(frozen=True)
class Vec:
    x: float; y: float
    def __add__(self, o): return Vec(self.x+o.x, self.y+o.y)
    def __lt__(self, o): return (self.x, self.y) < (o.x, o.y)
```

---

## Enum for choices

```python
from enum import Enum, auto
class Side(Enum): BUY = auto(); SELL = auto()
```

---

## Knowledge check (quiz)

- When prefer dataclass over regular class?
- What’s a Protocol good for?

---

## Wrap‑up

- You can model data with classes/dataclasses and add type hints
- Next: NumPy and pandas
